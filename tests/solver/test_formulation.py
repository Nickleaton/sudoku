import inspect
import unittest
from pathlib import Path
from typing import List, Dict

from pulp import LpVariable, LpInteger, LpProblem, LpMinimize, getSolver, LpContinuous, LpSolver

from src.solvers.formulations import Formulations


class TestFormulation(unittest.TestCase):
    logs: Dict[str, int] = {}
    lp_files: Dict[str, int] = {}

    def setUp(self) -> None:
        """Initializes the test environment by setting up the base directory, log path, and lp path.
        Creates the log and lp directories if they do not exist.
        """
        self.base = Path("output/formulations")
        self.log_path = self.base / Path("logs")
        self.lp_path = self.base / Path("lp")
        self.log_path.mkdir(exist_ok=True, parents=True)
        self.lp_path.mkdir(exist_ok=True, parents=True)

    def get_application(self, name: str) -> LpSolver:
        """Retrieves an LpSolver instance based on the provided name.

        Args:
            name (str): The name of the solver.

        Returns:
            LpSolver: An instance of the LpSolver class.
        """
        if name not in TestFormulation.logs:
            TestFormulation.logs[name] = 0
        else:
            TestFormulation.logs[name] += 1
        log_file_name = Path(f"{name}_{TestFormulation.logs[name]}.log")
        log_file = self.log_path / log_file_name
        return getSolver('PULP_CBC_CMD', logPath=str(log_file), msg=False, timeLimit=60)

    def get_lp_filename(self, name: str) -> Path:
        """Returns the filename for an LP file based on the provided name.

        The filename is generated by appending a sequential number to the provided name.
        The sequential number is incremented each time the function is called with the same name.

        Args:
            name (str): The base name of the LP file.

        Returns:
            Path: The full path of the LP file.
        """
        if name not in TestFormulation.lp_files:
            TestFormulation.lp_files[name] = 0
        else:
            TestFormulation.lp_files[name] += 1
        file_name = Path(f"{name}_{TestFormulation.lp_files[name]}.lp")
        return self.lp_path / file_name

    def absolute_int(self, v1: int, v2: int, expected: int) -> None:
        """Tests the absolute difference between two integer values using linear programming.

        Parameters
        ----------
        v1 (int): The first integer value.
        v2 (int): The second integer value.
        expected (int): The expected result of the absolute difference.

        Returns
        -------
        None
        """
        model = LpProblem("absolute_int", LpMinimize)
        x = LpVariable("minimum", 0, 9, LpInteger)
        x1 = LpVariable("x1", 1, 9, LpInteger)
        x2 = LpVariable("x2", 1, 9, LpInteger)

        model += x1 == v1
        model += x2 == v2
        model += x == Formulations.abs(model, x1, x2, 9)
        model.writeLP(str(self.get_lp_filename(inspect.currentframe().f_code.co_name)))
        model.solve(self.get_application(inspect.currentframe().f_code.co_name))
        self.assertEqual(expected, x.varValue)

    def test_absolute_int(self) -> None:
        """Tests the absolute_int function with different integer inputs.

        This function calls the absolute_int function with various integer values to verify its correctness.

        Returns:
            None
        """
        self.absolute_int(3, 9, 6)
        self.absolute_int(5, 3, 2)
        self.absolute_int(1, 1, 0)

    def absolute_float(self, v1: float, v2: float, expected: float) -> None:
        """Tests the absolute difference between two floating point numbers using linear programming.

        This function creates a linear programming problem, defines variables, and solves for the absolute difference
        between two input values.

        Parameters
        ----------
            self (TestFormulation): The current test case instance.
            v1 (float): The first floating point number.
            v2 (float): The second floating point number.
            expected (float): The expected absolute difference between v1 and v2.

        Returns
        -------
            None
        """
        model = LpProblem("absolute_float", LpMinimize)
        x = LpVariable("minimum", 0, 9, LpContinuous)
        x1 = LpVariable("x1", 1, 9, LpContinuous)
        x2 = LpVariable("x2", 1, 9, LpContinuous)

        model += x1 == v1
        model += x2 == v2
        model += x == Formulations.abs(model, x1, x2, 9)
        model.writeLP(str(self.get_lp_filename(inspect.currentframe().f_code.co_name)))
        model.solve(self.get_application(inspect.currentframe().f_code.co_name))
        self.assertEqual(expected, x.varValue)

    def test_absolute_float(self) -> None:
        """Test the `absolute_float` function with various input values and expected outputs.

        This function calls the `absolute_float` function multiple times with different input values and checks
        if the returned value matches the expected output.

        Parameters
        ----------
            self (TestFormulation): The current test case instance.

        Returns
        -------
            None
        """
        self.absolute_float(3.0, 9.0, 6.0)
        self.absolute_float(5.0, 3.0, 2.0)
        self.absolute_float(1.0, 1.0, 0.0)
        self.absolute_float(1.5, 2.8, 1.3)
        self.absolute_float(4.5, 2.8, 1.7)

    def minimum(self, values: List[int], expected: int) -> None:
        """Tests the minimum function by providing a list of integer values and an expected minimum value.

        This function creates a linear programming problem, defines variables, and solves for the minimum value.

        Args:
            values (List[int]): A list of integer values to find the minimum of.
            expected (int): The expected minimum value.

        Returns:
            None
        """
        model = LpProblem("minimum", LpMinimize)
        variables: List[LpVariable] = []
        for i, value in enumerate(values):
            x = LpVariable(f"x{i}", 1, 9, LpInteger)
            model += x == value
            variables.append(x)

        mini = Formulations.minimum(model, variables, 1, 9)
        model.writeLP(str(self.get_lp_filename(inspect.currentframe().f_code.co_name)))
        model.solve(self.get_application(inspect.currentframe().f_code.co_name))
        self.assertEqual(expected, mini.varValue)

    def test_minimum(self) -> None:
        """Tests the minimum function by providing various input lists and expected minimum values.

        The function calls the minimum function with different input lists and expected minimum values,
        and asserts that the actual minimum value is equal to the expected minimum value.

        Returns:
            None
        """
        self.minimum([2, 2, 2], 2)
        self.minimum([1, 2, 3], 1)
        self.minimum([3, 2, 1], 1)

    def maximum(self, values: List[int], expected: int) -> None:
        """Tests the maximum function by creating a linear programming problem,
        defining variables, and solving for the maximum value.

        Args:
            values (List[int]): A list of integer values to find the maximum of.
            expected (int): The expected maximum value.

        Returns:
            None
        """
        model = LpProblem("maximum", LpMinimize)
        variables: List[LpVariable] = []
        for i, value in enumerate(values):
            x = LpVariable(f"x{i}", 1, 9, LpInteger)
            model += x == value
            variables.append(x)

        maxi = Formulations.maximum(model, variables, 1, 9)
        model.writeLP(str(self.get_lp_filename(inspect.currentframe().f_code.co_name)))
        model.solve(self.get_application(inspect.currentframe().f_code.co_name))
        self.assertEqual(expected, maxi.varValue)

    def test_maximum(self) -> None:
        """Tests the maximum function with various input values.

        This function calls the maximum function with different lists of integers and expected maximum values.
        It asserts that the result of the maximum function is equal to the expected maximum value.

        Returns:
            None
        """
        self.maximum([1, 2, 3], 3)
        self.maximum([3, 2, 1], 3)
        self.maximum([2, 2, 2], 2)

    def logical_not(self, value: int, expected: int) -> None:
        """Tests the logical NOT operation between a binary value and an expected result.

        Args:
            value (int): The binary value to be negated.
            expected (int): The expected result of the logical NOT operation.

        Returns:
            None
        """
        model = LpProblem("logical_not", LpMinimize)
        x = LpVariable("x", 0, 1, LpInteger)
        model += x == value
        y = Formulations.logical_not(model, x)
        model.writeLP(str(self.get_lp_filename(inspect.currentframe().f_code.co_name)))
        model.solve(self.get_application(inspect.currentframe().f_code.co_name))
        self.assertEqual(expected, y.varValue)

    def test_logical_not(self):
        """Tests the logical NOT operation between two binary values.

        Parameters
        ----------
        None

        Returns
        -------
        None
        """
        self.logical_not(1, 0)
        self.logical_not(0, 1)

    def logical_or(self, value1: int, value2: int, expected: int) -> None:
        """Tests the logical OR operation between two binary values.

        Parameters
        ----------
        value1 (int): The first binary value.
        value2 (int): The second binary value.
        expected (int): The expected result of the logical OR operation.

        Returns
        -------
        None
        """
        model = LpProblem("logical_or", LpMinimize)
        x1 = LpVariable("x1", 0, 1, LpInteger)
        x2 = LpVariable("x2", 0, 1, LpInteger)
        model += x1 == value1
        model += x2 == value2
        y = Formulations.logical_or(model, [x1, x2])
        model.writeLP(str(self.get_lp_filename(inspect.currentframe().f_code.co_name)))
        model.solve(self.get_application(inspect.currentframe().f_code.co_name))
        self.assertEqual(expected, y.varValue)

    def test_logical_or(self):
        """Tests the logical OR operation between two binary values with various combinations.

        This function calls the logical_or function with different pairs of binary values and their expected results.

        Parameters
        ----------
        None

        Returns
        -------
        None
        """
        self.logical_or(0, 0, 0)
        self.logical_or(0, 1, 1)
        self.logical_or(1, 0, 1)
        self.logical_or(1, 1, 1)

    def logical_and(self, value1: int, value2: int, expected: int) -> None:
        """Tests the logical AND operation between two binary values.

        Parameters
        ----------
        value1 (int): The first binary value.
        value2 (int): The second binary value.
        expected (int): The expected result of the logical AND operation.

        Returns
        -------
        None
        """
        model = LpProblem("logical_and", LpMinimize)
        x1 = LpVariable("x1", 0, 1, LpInteger)
        x2 = LpVariable("x2", 0, 1, LpInteger)
        model += x1 == value1
        model += x2 == value2
        y = Formulations.logical_and(model, [x1, x2])
        model.writeLP(str(self.get_lp_filename(inspect.currentframe().f_code.co_name)))
        model.solve(self.get_application(inspect.currentframe().f_code.co_name))
        self.assertEqual(expected, y.varValue)

    def test_logical_and(self):
        """Tests the logical_and function with various input combinations.

        The test cases cover all possible combinations of two binary inputs,
        ensuring the function behaves correctly for all scenarios.
        """
        self.logical_and(0, 0, 0)
        self.logical_and(0, 1, 0)
        self.logical_and(1, 0, 0)
        self.logical_and(1, 1, 1)


if __name__ == '__main__':  # pragma: no cover
    unittest.main()
